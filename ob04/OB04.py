###Задание: Применение Принципа Открытости/Закрытости (Open/Closed Principle) в Разработке Простой Игры
###Цель: Цель этого домашнего задание - закрепить понимание и навыки применения принципа открытости/закрытости (Open/Closed Principle), одного из пяти SOLID принципов объектно-ориентированного программирования. Принцип гласит, что программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.
###Задача: Разработать простую игру, где игрок может использовать различные типы оружия для борьбы с монстрами. Программа должна быть спроектирована таким образом, чтобы легко можно было добавлять новые типы оружия, не изменяя существующий код бойцов или механизм боя.
###Исходные данные:
###Есть класс Fighter, представляющий бойца.
###Есть класс Monster, представляющий монстра.
###Игрок управляет бойцом и может выбирать для него одно из вооружений для боя.
###Шаг 1: Создайте абстрактный класс для оружия
###Создайте абстрактный класс Weapon, который будет содержать абстрактный метод attack().
###Шаг 2: Реализуйте конкретные типы оружия
###Создайте несколько классов, унаследованных от Weapon, например, Sword и Bow. Каждый из этих классов реализует метод attack() своим уникальным способом.
###Шаг 3: Модифицируйте класс Fighter
###Добавьте в класс Fighter поле, которое будет хранить объект класса Weapon.
###Добавьте метод change_weapon(), который позволяет изменить оружие бойца.
###Шаг 4: Реализация боя
###Реализуйте простой механизм для демонстрации боя между бойцом и монстром, исходя из выбранного оружия.
###Требования к заданию:
###Код должен быть написан на Python.
###Программа должна демонстрировать применение принципа открытости/закрытости: новые типы оружия можно легко добавлять, не изменяя существующие классы бойцов и механизм боя.
###Программа должна выводить результат боя в консоль.
###Пример результата:
###Боец выбирает меч.
###Боец наносит удар мечом.
###Монстр побежден!
###Боец выбирает лук.
###Боец наносит удар из лука.
###Монстр побежден!

from abc import ABC, abstractmethod             # импортируем библиотеки для создания абстрактных классов

class Weapon(ABC):                              # абстрактный класс для оружия
    @abstractmethod
    def attack(self):
        pass

class Sword(Weapon):                            # класс Меч - один из видов оружия
    def __init__(self):
        self.name = "меч"                       # название оружия
    def attack(self):                           # метод attack для меча
        return "наносит удар мечом."

class Bow(Weapon):                              # класс Лук - другой вид оружия
    def __init__(self):
        self.name = "лук"                       # название оружия
    def attack(self):                           # метод attack для лука
        return "делает выстрел из лука."

class Fighter:                                  # класс Боец
    def __init__(self):                         # определяем бойца без оружия
        self.weapon = None

    def change_weapon(self, new_weapon):        # метод меняет оружие бойцу
        self.weapon = new_weapon
        print("Боец выбирает", new_weapon.name)

    def fight(self, monster):                   # боец атакует
        if self.weapon:
            print(f"Боец {self.weapon.attack()}")
            print(f"{monster.name} побежден!\n")
        else:
            print("Боец безоружен!\n")

class Monster:                                  # класс Монстр
    def __init__(self, name):
        self.name = name                        # имя монстра

# Демонстрация работы программы
if __name__ == "__main__":
    hero = Fighter()                            # создаем бойца - герой
    goblin = Monster("Гоблин")                  # создаем монстра - гоблин
    orc = Monster("Орк")                        # создаем монстра - орк

    hero.change_weapon(Sword())                 # герой выбирает меч
    hero.fight(goblin)                          # герой атакует гоблина

    hero.change_weapon(Bow())                   # герой выбирает лук
    hero.fight(orc)                             # герой атакует циклопа

# Пример добавления нового оружия
    class Axe(Weapon):                          # класс Топор - новый вид оружия
        def __init__(self):
            self.name = "топор"                 # название оружия
        def attack(self):                       # метод attack для топора
            return "рубит топором."

    dragon = Monster("Дракон")                  # создаем монстра - дракон

    hero.change_weapon(Axe())                   # герой выбирает топор
    hero.fight(dragon)                          # герой атакует дракона

